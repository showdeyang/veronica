# -*- coding: utf-8 -*-
#This script trains a model that determines whether a sentence can answer a given question well.
import json
import numpy as np
import math
import re
import jieba
import random
import matplotlib.pyplot as plt 

with open('./baidu_zhidao.json','r') as f:
    data = json.loads(f.read())

rawData = []
for qa in data:
    q = qa['q']
    if 'ans' in qa.keys():
        if len(qa['ans']) > 0:
            ans = [item['a'].replace('展开全部','') for item in qa['ans']]
    rawData.append([q,ans])
    
def relevance(qc,ac):
    c = 0 
    for x in qc:
        if x in ac:
            c += 1
    if len(qc) == 0:
        return 0
    else:
        return c/len(qc)

def depth(qc,ac):
    c = 0 
    for x in ac:
        if x in qc:
            c += 1
    if len(ac) == 0:
        return 0
    else:
        return c/len(ac)
    
def relevance2(qc,ac):
    qc = [item for item in qc if len(item)>=2]
    ac = [item for item in ac if len(item)>=2]
    c = 0 
    for x in qc:
        if x in ac:
            c += 1
    if len(qc) == 0:
        return 0
    else:
        return c/len(qc)

def depth2(qc,ac):
    qc = [item for item in qc if len(item)>=2]
    ac = [item for item in ac if len(item)>=2]
    c = 0 
    for x in ac:
        if x in qc:
            c += 1
    if len(ac) == 0:
        return 0
    else:
        return c/len(ac)

def qInA(q,a):
    c = 0
    for char in q:
        if char in a:
            c += 1
    if len(q) == 0:
        return 0
    else:
        return c/len(q)
    
def aInQ(q,a):
    c = 0
    for char in a:
        if char in q:
            c += 1
    if len(a) == 0:
        return 0
    else:
        return c/len(a)

def score(qc,ac):
    return relevance(qc,ac)*depth(qc,ac)

def score2(qc,ac):
    return relevance2(qc,ac)*depth2(qc,ac)

def prepareX(pair, ID):
    #this only prepares a row of X for a (q,a)-pair.
    q,a = pair[0], pair[1]
    qc,ac = list(jieba.cut(q)), list(jieba.cut(a))
    row = [score(qc,ac), score2(qc,ac), ID]
    #relevance(qc,ac), depth(qc,ac), relevance2(qc,ac), depth2(qc,ac), qInA(q,a), aInQ(q,a), len(qc), len(ac), 
    return row

def goodPairs(rawData):
    results = []
    for qa in rawData:
        for i in range(len(qa[1])):
            pair = [qa[0], qa[1][i]] 
            results.append(pair)
    return results
    
def badPairs(rawData,n=len(rawData)):
    results = []
    for i in range(n):
        c = random.choices(rawData,k=2)
        data1,data2 = c[0],c[1]
        q,a = data1[0],random.choice(data2[1])
        pair = [q,a]
        results.append(pair)
    return results

def relu(z):
    #this modifies z in-place, this is the fastest way of doing ReLu. 
    z[z<0] = 0
    
def sigmoid(z):
    z[z>= 30] = 30
    return 1/(1+np.exp(-z))
    
def mlp(x, y, h=[]):
    #example: h = [50,20,10] means this mlp has three hidden layers of node count 50, 20 and 10 respectively. Default: no hidden layer.
    def genLayer(a1,a2):
        #a1 = input array size, a2 = output array size
        w = np.random.uniform(-10,10, size=(a1, a2))
        b = np.random.uniform(-10,10,a2)
        return w,b
    params = []
    if len(h) == 0: 
        w,b = genLayer(x,y)
        params.append((w,b))
    else:
        a = x
        for hl in h:
            #print(hl)
            w,b = genLayer(a,hl)
            params.append((w,b))
            a = len(b)
        #finally, between last h and output
        w,b = genLayer(h[-1],y)
        params.append((w,b))
    return params

def feedForward(x, params, onehot=True):
    #x,y must be numpy arrays, params must be generated by mlp().
    a = x
    h = []
    i = 1
    for param in params:
        w,b = param
        mul = np.dot(a,w)
        #print(np.size(mul))
        a = np.add(mul,b)
        #relu(a)
        a = sigmoid(a)
        if i < len(params):
            h.append(a)
        i += 1
        #print(params.index(param))
    
    if onehot:
        a[a>30] = 30
        #a[a<-9999] = -99
        #print(a)
        #print(np.sum(np.exp(a)))
        #y = np.exp(a)/np.sum(np.exp(a))
        y = a/np.sum(a)
        
    else:
        y = a
    return y,h

def predict(q,a,params):
    x = np.array(prepareX([q,a],0)[:-1])
    y,h = feedForward(x,params,onehot=False)
    y = y.flatten()
    return y

def mutation(params, variation, rate=1, offsprings=10):
    os = []
    for i in range(offsprings):
        rparams = []
        for param in params:
            w,b = param
            rw = w + np.random.normal(0,variation,np.shape(w))
            rb = b + np.random.normal(0,variation,np.shape(b))
            rparam = rw,rb
            rparams.append(rparam)
        os.append(rparams)
    return os

def training(xs, ys, teX, teY, n=50, decision=0.5):
    params = mlp(2,1, h=[10])
    minLoss = 1
    iteration = 0
    for j in range(n):
        iteration += 1
        dev = math.sqrt(10*10)/(math.sqrt(j+1))
        params_offsprings = mutation(params,dev)
        offsprings = range(len(params_offsprings))
        print('training iteration',iteration)
        losses = []
        for i in offsprings:
            #i = 0,1,2,3,..., no of offsprings-1
            params = params_offsprings[i]
            
            ypred,h = feedForward(xs,params,onehot=False)
            ypred = ypred.flatten()
            ypred[ypred<decision] = 0
            ypred[ypred>=decision] = 1
            #print(np.shape(ypred))

            #loss = np.mean(np.abs(ypred-ys))
            TP = 0
            AP = np.sum(ypred)
            for i in range(len(ypred)):
                if ypred[i] == 1 and ys[i]==1:
                    TP += 1
            if AP == 0:
                TPR = 0
                
            else:
                TPR = TP/AP
            
            loss = TPR
            
            #loss = np.sum(np.abs(ys - ypred))/len(ys)
            #p = 1 - (e/len(teY))
            #print(loss)
            losses.append(loss)
        minLoss = np.max(losses)
        minInd = losses.index(minLoss)
        #survival params
        params = params_offsprings[minInd]
        ypred,h = feedForward(teX,params,onehot=False)
        ypred = ypred.flatten()
        ypred[ypred<decision] = 0
        ypred[ypred>=decision] = 1
        print(np.shape(teY),np.shape(ypred))
        print(ypred)
        print(np.abs(teY - ypred))
        e = np.sum(np.abs(teY - ypred))
        p = 1 - (e/len(teY))
        
        TP = 0
        AP = np.sum(ypred)
        for i in range(len(ypred)):
            if ypred[i] == 1 and teY[i]==1:
                TP += 1
        if AP == 0:
            TPR=0
        else:
            TPR = TP/AP
        
        #loss = TPR
        
        print('loss',minLoss)
        print('dev', dev)
        print('training TPR', minLoss)
        print('test TPR',TPR)
        #print(len(answer))
        print('\n#################\n')
              
    return params



test_ratio = 0.3
train_ratio = 1 - test_ratio
n = len(rawData) #the number of questions

gP,bP = goodPairs(rawData), badPairs(rawData,3*len(rawData))
random.shuffle(gP)
random.shuffle(bP)

gpi,bpi = int(len(gP)*train_ratio), int(len(bP)*train_ratio)
test_set_good, test_set_bad = gP[gpi:], bP[bpi:]
train_set_good, train_set_bad = gP[:gpi], bP[:bpi]

train_dataset = []
test_dataset = []

for i in range(len(train_set_good)):
    train_dataset.append( prepareX(train_set_good[i],i) + [train_set_good[i][0], train_set_good[i][1], 1] )
for j in range(len(train_set_bad)):
    i = len(train_set_good)
    train_dataset.append( prepareX(train_set_bad[j],i+j) + [train_set_bad[j][0], train_set_bad[j][1], 0] )  
    
for i in range(len(test_set_good)):
    test_dataset.append( prepareX(test_set_good[i],i) + [test_set_good[i][0], test_set_good[i][1], 1] )
for j in range(len(test_set_bad)):
    i = len(test_set_good)
    test_dataset.append( prepareX(test_set_bad[j],i+j) + [test_set_bad[j][0], test_set_bad[j][1], 0] )  

random.shuffle(train_dataset)
random.shuffle(test_dataset)

trX = np.array([row[:2] for row in train_dataset])
trY = np.array([row[-1] for row in train_dataset])

teX = np.array([row[:2] for row in test_dataset])
teY = np.array([row[-1] for row in test_dataset])
########################################
##Plotting
#
## Create data
#
#x1 = [row[3] for row in train_dataset if row[-1]==1]
##print(len(x))
#y1 = [row[4] for row in train_dataset if row[-1]==1]
#
#x2 = [row[3] for row in train_dataset if row[-1]==0]
##print(len(x))
#y2 = [row[4] for row in train_dataset if row[-1]==0]
#
#
#
#c1 = 'blue'
#c2 = 'red'
## Plot
#plt.scatter(x1, y1, c=c1, alpha=0.1)
##plt.scatter(x2, y2, c=c2, alpha=0.1)
#plt.title('Scatter plot pythonspot.com')
#plt.xlabel('relevance')
#plt.ylabel('relevance2')
#
#plt.show()

###############################
#Training
'''
适合冬天的运动有哪些？',
  '冬季运动宜选择轻松平缓、活动量不大的项目，如滑雪、慢跑、徒步、自行车等户外运动，以及高温瑜伽、游泳、普拉提等室内项目。适当减少登山、球类运动，以防止运动量过大使免疫力降低，诱发感冒、肺炎等疾病。'''
params = training(trX,trY,teX,teY)
z = predict('怎么判断自己喜不喜欢一个男生？', '''如果你经常注意他，假如你看到他受到伤害的时候你会心疼，就说明你喜欢他了 ''', params)
print(z)